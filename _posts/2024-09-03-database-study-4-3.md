---
title: 데이터베이스 스터디 4주차 - 정규화

author: milktea
date: 2024-09-02 14:00:00 +0800
categories: [Database]
tags: [FunctionalDependency]
pin: true
math: true
mermaid: true
---
# 1. 정규화(Normalization)

정규화는 데이터의 중복을 제거하거나 최소화하고 데이터 종속이 논리적으로 표현되도록 데이터를 재구성하는 과정이다.
이 과정을 수행함으로써 데이터 이상 현상이 제거된다.

---
# 2. 제 1 정규형(First Normal Form, 1NF)

> 제 1 정규형은 릴레이션 내 모든 데이터가 스칼라 값만 가지고 데이터 그룹을 속성으로 가질 수 없다.
{: .prompt-info }

## 제 1 정규형 위반 사례

| student_id | Subject_name       |
|------------|--------------------|
| 1          | Algorithm, Network |
| 2          | Database           |
| 3          | Network, Database  |

| student_id | subject_name_1 | subject_name_2 |
|------------|----------------|----------------|
| 1          | Algorithm      | Network        |
| 2          | Database       | None           |
| 3          | Network        | Database       |

위의 두 테이블은 모두 1 정규형을 위반하고 있다.
이렇게 테이블을 구성했을 때 문제점은 다음과 같다.

1. 데이터 조회 시 복잡하다. 특히 첫 번째 테이블의 경우 추가적인 문자열 파싱이 필요할 수 있다.
2. 유연성이 떨어진다. 특히 두 번째 테이블의 경우 수업을 3개 이상 듣는 학생이 있다면 새로운 컬럼을 추가하는 작업이 필요하다.
3. 삽입 이상이 발생한다. 특히 두 번째 테이블의 경우 2번 튜플처럼 듣는 과목이 하나일 때 'None'이라는 불필요한 값을 추가해야 한다.
4. 갱신 이상이 발생한다. Network을 Computer Network로 변경하고 싶다면 모든 튜플들 내 Network을 변경하지 않으면 데이터가 불일치 되는 문제가 발생한다.
5. 삭제 이상이 발생한다. 1번 학생을 삭제할 때 Algorithm이란 과목도 함께 삭제가 된다.

이 제 1 정규형을 만족하지 않을 때 가장 큰 문제는 **데이터를 조회하고 조작하기 어렵다**는 점이다.

## 제 1 정규형 도입

| student_id | subject_name |
|------------|--------------|
| 1          | Algorithm    |
| 1          | Network      |
| 2          | Database     |
| 3          | Network      |
| 3          | Database     |

1 정규형을 도입하면 문자열 처리 등의 과정이 생략되어 데이터 조회와 조작이 간편해진다.
하지만 1 정규형을 도입한 것 만으로는 이상 현상이 해결되지 않아 추가적인 정규화 과정이 필요하다.

---

# 3. 제 2 정규형(2NF)

> 제 2 정규형은 제 1 정규형을 만족하면서 후보 키가 아닌 모든 속성이 후보 키에 대해 완전 함수적 종속이어야 한다.
{: .prompt-info }

## 제 2 정규형 위반 사례

| student_id | student_name | subject_id | subject_name | score |
|------------|--------------|------------|--------------|-------|
| 1          | Kim          | 1          | Database     | A0    |
| 1          | Kim          | 2          | Algorithm    | B0    |
| 2          | Park         | 2          | Algorithm    | A0    |
| 2          | Park         | 3          | Network      | B+    |

이 경우 student_id, subject_id -> subject_name을 만족하지만 student_id를 제외해도 subject_id -> subject_name 함수 종속성을 만족한다.
이 때 subject_name이라는 후보 키가 아닌 속성이 후보 키 (student_id, subject_id)에 대해 부분 함수적 종속을 만족하므로 제 2 정규형을 위반한다.
이렇게 테이블을 구성하면 1 정규형에 비해 데이터를 조회하고 조작하기는 쉬워졌지만 여전히 여러 이상 현상들이 나타날 수 있다.

1. 삽입 이상이 발생한다. 아직 학생이 없는 과목을 개설할 때 학생 정보에 의미없는 값을 추가해야 한다.
2. 갱신 이상이 발생한다. Algorithm의 과목 이름을 변경할 때 모든 이름을 변경하지 않으면 데이터 불일치가 발생한다.
3. 삭제 이상이 발생한다. Kim의 데이터를 삭제할 때 Database에 대한 정보가 함께 삭제될 수 있다.

## 제 2 정규형 도입

| student_id | student_name |
|------------|--------------|
| 1          | Kim          |
| 2          | Park         |

| subject_id | subject_name |
|------------|--------------|
| 1          | Database     |
| 2          | Algorithm    |
| 3          | Network      |

| student_id | subject_id | score |
|------------|------------|-------|
| 1          | 1          | A0    |
| 1          | 2          | B0    |
| 2          | 2          | A0    |
| 2          | 3          | B+    |

제 2 정규형을 도입한 결과 중복되는 데이터를 제거하여 기존 테이블의 갱신 이상, 삽입 이상 및 삭제 이상 문제를 해결할 수 있다.
하지만 제 2 정규형은 특정한 상황에서는 여전히 이상 현상이 발생할 수 있다.
이를 해결하기 위해 제 3 정규형을 해결할 수 있다.

---
# 4. 제 3 정규형(3NF)

> 제 3 정규형은 제 2 정규형을 만족하면서 후보 키가 아닌 모든 속성이 후보 키에 대하여 이행적 함수 종속성이 없어야 한다.
{: .prompt-info }

## 제 3 정규형 위반 사례

| id | state | city          | street_name         |
|----|-------|---------------|---------------------|
| 1  | NY    | New York City | Broadway            |
| 2  | CA    | Los Angeles   | Sunset Boulevard    |
| 3  | IL    | Chicago       | Michigan Avenue     |
| 4  | TX    | Houston       | Westheimer Road     |
| 5  | CA    | Los Angeles   | Hollywood Boulevard |
| 6  | NY    | New York City | Fifth Avenue        |
| 7  | CA    | San Francisco | Lombard Street      |

제 2 정규형을 도입하더라도 테이블 내 이행적 함수 종속성이 있는 경우 여전히 이상 현상이 발생할 수 있다.
이 테이블은 기본 키가 단일 속성이므로 기본 키를 제외한 모든 속성이 완전 함수적 종속을 만족하므로 2 정규형이 적용되었다.

이 때 id -> city, city -> state 함수 종속성을 만족하면서 id -> state 함수 종속성을 만족한다.
이 경우 기본 키가 아닌 속성인 state와 city가 기본 키에 대해 이행적 함수 종속성을 만족한다.
이행적 함수 종속성은 키가 아닌 속성들 간의 종속성이 존재하므로 데이터가 중복될 가능성이 높다.

1. 삽입 이상이 발생한다. street_name 없이 state와 city만 넣어야 하는 경우 의미없는 값을 넣어야 한다.
2. 갱신 이상이 발생한다. 한 city의 이름이 변경될 때 모든 이름을 변경하지 않으면 데이터가 불일치될 수 있다.

이와 같이 이상 현상이 발생할 수 있으므로 정규형을 통해 이행적 함수 종속성을 제거해야 한다.

## 제 3 정규형 도입

| id | state |
|----|-------|
| 1  | NY    |
| 2  | CA    |
| 3  | IL    |
| 4  | TX    |

| id | state_id | city_name     |
|----|----------|---------------|
| 1  | 1        | New York City |
| 2  | 2        | Los Angeles   |
| 3  | 2        | San Francisco |
| 4  | 3        | Chicago       |
| 5  | 4        | Houston       |

| id | city_id | street_name         |
|----|---------|---------------------|
| 1  | 1       | Broadway            |
| 2  | 1       | Fifth Avenue        |
| 3  | 2       | Sunset Boulevard    |
| 4  | 2       | Hollywood Boulevard |
| 5  | 3       | Lombard Street      |
| 6  | 4       | Michigan Avenue     |
| 7  | 5       | Westheimer Road     |

이 테이블과 같이 함수 종속성을 제거할 수 있다.
제 3 정규형을 도입하기 전과 달리 데이터 중복이 존재하지 않아 갱신 이상이 발생하지 않는다.
또한 삽입 이상도 발생하지 않는다.

하지만 제 3 정규형도 이러한 사례 외에 아주 특이한 상황에서 이상 현상이 발생할 수도 있다.
이러한 특이한 상황에서 이상 현상을 제거하기 위해 BCNF, 4NF, 5NF를 도입할 수 있지만 성능이 저하될 수 있으므로 이를 고려하여 도입해야 한다.

---
# 4. 반정규화

정규화를 도입하면 어떠한 성능 상의 문제가 생길 수 있을까?
먼저 위의 정규화 결과와 같이 정규화는 데이터 중복을 피하기 위해 하나의 테이블이 여러 테이블로 분리가 될 가능성이 높다.
이 경우 모든 데이터를 조회하기 위해서는 조인 과정을 거쳐야 한다.
이러한 조인 과정은 추가적인 비용이 발생한다.

따라서 의도적으로 정규화 원칙을 위배하여 데이터 무결성 측면에서 손실은 감수하는 대신 성능 향상의 이점을 가져올 수 있다.
이를 **반정규화**라고 한다.
반정규화의 장점이 정규화의 단점이 되고 반정규화의 단점이 정규화의 장점이 되므로 이 둘을 비교하면 다음과 같다.

|               | 정규화                                                                   | 반정규화                                                                                                                                                                   |
|---------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 데이터 무결성 | 데이터 무결성을 준수하여 일관되고<br> 정확한 데이터를 관리할 수 있다.    | 데이터 무결성을 만족하지 못하여 데이터 불일치,<br>데이터 중복 등이 발생할 수 있다.                                                                                         |
| 조회 측면     | 테이블이 많을 가능성이 높아 조인 연산으로<br>조회 성능이 감소할 수 있다. | 정규화에 비해 테이블의 수가 적어 조인 연산이 적어 <br>조회 성능이 좋다. 또한 반정규화는 자주 조회하는<br>데이터를 중복으로 저장하여 조회 성능을 더욱 향상<br>시킬 수 있다. |
| 쓰기 측면     | 중복된 데이터가 없어 삽입과 수정 시 고려<br>해야 할 사항들이 적다.       | 중복된 데이터가 있어 데이터 일관성을 유지하기 위해<br>서는 삽입과 수정 시 중복된 데이터 전부를 변경해야<br>할 수도 있다.                                                   |

반정규화는 논리적 데이터 모델링에서 정규화를 도입한 이후인 물리적 데이터 모델링 단계에서 수행된다. 


## 반정규화 도입 예시

대량의 데이터를 처리할 때 파티션, 인덱스 설계 등을 통해 해결할 수 없을 때가 있다.
이러한 성능 문제를 예방하기 위해 반정규화를 도입하여 조회 성능을 향상할 수 있다.


### 집계/요약 테이블 추가

대량의 데이터를 읽어 부서, 일별로 집계하는 상황이 많을 것으로 예상될 때 집계 테이블을 설계할 수 있다.
이 때 다양한 집계 처리를 포함할 수 있도록 공통된 조건을 분석하여 설계하는 것이 좋다.

### 컬럼 추가

1. 부모 테이블에 인조키(Surrogate Key)가 기본 키로 
2. 


---
# Reference


### 4
[https://velog.io/@dddooo9/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94](https://velog.io/@dddooo9/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94)
