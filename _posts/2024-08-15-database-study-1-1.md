---
title: 데이터베이스 스터디 1주차 - DB의 개념, 스키마
author: milktea
date: 2024-08-15 10:00:00 +0800
categories: [Database]
tags: [Schema, DBMS]
pin: true
math: true
mermaid: true
---

# 1. 파일 시스템 vs 데이터 베이스
데이터베이스와 파일 시스템 모두 데이터를 영속적으로 저장하기 위한 시스템인 점에서 공통점을 가진다.
동일한 공통점을 가짐에도 두 가지 독립적인 시스템이 존재한다는 말은 두 시스템 사이 장단점이 있다고 추측할 수 있다.
결론부터 말하자면 데이터베이스는 **데이터의 중앙 통제적 제어** 특성을 가져 파일 시스템과 큰 차이를 가진다.
데이터의 중앙 통제적인 저장, 관리, 검색으로 데이터 중복을 줄일 수 있고, 불일치 데이터가 없으며, 데이터의 보안 통제가 효과적이다.

## 데이터의 중앙 통제적 제어
데이터베이스를 중앙 통제함으로써 데이터 공유, 중복 최소화, 불일치 제거, 트랜잭션 처리 지원, integerity 지원, 그리고 최종적으로 **데이터 독립성**을 지원한다.

### 중복 최소화와 불일치 제거 
데이터베이스 시스템을 사용하지 않는 파일 시스템은 응용 프로그램마다 필요한 파일을 생성하고 관리해야 한다.
따라서 파일 간에 데이터 중복이 발생하게 되며 이는 저장 공간의 낭비와 데이터를 변경할 때 기존 데이터와 불일치되는 문제가 발생한다.

반면 데이터베이스는 데이터가 통합되어 있어 중복이 제거되거나 최소화된다.

### 트랜잭션 처리 지원
데이터베이스는 하나의 논리적 작업 단위인 트랜잭션을 지원한다.
트랜잭션 또한 데이터 불일치를 해결하기 위한 요소이다.
A가 B에게 송금할 때 A의 잔액은 갱신되었지만 B의 잔액은 갱신되지 않으면 데이터 불일치가 발생하게 된다.

## 데이터베이스의 단점?
이러한 데이터베이스가 항상 장점만을 가지고 있지는 않다.
데이터베이스는 파일 시스템보다 고비용이다.
따라서 많은 용량을 가진 이미지, 비디오 등을 데이터베이스에 저장하면 비용, 성능 측면에서 파일 시스템보다 불리할 수 있으므로 데이터 형식에 따라 적절한 시스템을 선택하는 것이 중요하다.

## 결론
Database는 File System과 달리 중앙 통제적 제어가 가장 큰 특성이다.
이러한 중앙 통제적 제어가 가능한 덕분에 데이터 중복을 최소화하고, 여러 응용 프로그램이 데이터를 사용할 수 있으며 데이터의 제약 조건을 추가할 수 있다.
하지만 Database는 상대적으로 고비용이므로 파일 시스템과 데이터베이스를 선택할 때 비용과 데이터 독립성, 무결성을 동시에 고려하여 선택할 필요가 있다.

|         | Database        | File System        |
|---------|-----------------|--------------------|
| 데이터 중복  | 없거나 최소로 유지      | 중복 데이터 존재          |
| 데이터 공유  | 중앙 통제적 제어로 쉬움   | 여러 파일에 분산되어 공유 어려움 |
| 데이터 무결성 | 무결성 제약 조건 유지    | 무결성 제약 조건 구현 어려움   |
| 데이터 독립성 | DBMS로 독립성 유지 가능 | 독립성 없음             |
| 저장 비용   | 상대적으로 고비용       | 상대적으로 저비용          |

---
# 2. 데이터베이스의 특징
데이터베이스 시스템과 구분되는 데이터베이스 개념은 연관된 정보의 집합이다.
예를 들어 전화번호부는 특정 지역에 거주하는 모든 사람의 이름, 전화번호와 주소 데이터베이스이다.
하지만 이런 오프라인 형식의 데이터베이스는 검색, 데이터 추가, 삭제 등이 어려웠다.
따라서 이를 해결하기 위해 전산화된 데이터 저장 및 검색 메커니즘을 가진 **데이터베이스 시스템**이 등장하였다.

## 데이터베이스 시스템 특징
1. 실시간 접근(real-time accessibility)
오프라인 형식의 데이터베이스와 달리 사용자의 데이터 요구에 실시간으로 응답할 수 있어야 한다.

2. 계속되는 변화(Continuous Evolution)
데이터베이스 시스템은 현실 세계의 상태를 정확히 반영해야 한다.
현실 세계의 변화에 맞게 데이터 베이스도 끊임없이 변해야 한다.

3. 동시 공유(Concurrent Sharing)
데이터베이스 시스템은 여러 사용자가 동시에 이용할 수 있다.
같은 데이터를 동시에 사용할 수 있어야 한다.

4. 내용 참조(Content Reference)
데이터베이스는 저장된 주소나 위치를 알지 않고 데이터의 내용 만으로도 데이터를 참조할 수 있다.
이는 쿼리를 통해 구현된다.

---
# 3. DBMS
DBMS는 데이터베이스에 대한 사용자 또는 응용 프로그램의 요청을 처리하는 **소프트웨어**로서 3단계 구조의 스키마를 표현하고 매핑 처리한다.
DBMS는 사용자가 DB 접근 요청을 하면 External Schema를 찾고 이를 Conceptual Schema, Internal Schema와 매핑하여 물리적 데이터베이스에 접근한다.

따라서 DBMS는 데이터 독립성을 지원하며 추가로 데이터 무결성, 데이터 일관성, 데이터 보안성 등을 여러 고급 기능으로 지원한다.

---
# 4. 스키마와 3단계 데이터베이스 구조
## 스키마
스키마는 관계형 데이터베이스 내에서 데이터가 구성되는 방식을 정의한다.
여기에는 테이블 이름, 필드, 데이터 형식 및 이러한 엔티티 간의 관계와 같은 논리적 제약 조건이 포함된다.

## 3단계 데이터베이스 스키마
**3단계 데이터베이스 스키마는 데이터 독립성을 실현하기 위한 요소**이다.
이 3단계 스키마는 data dictionary(테이블의 메타데이터) 간의 추상적인 관계를 표현한다.
이러한 3단계 데이터베이스 스키마 구조로 사용자는 추상화된 논리적 테이블 구조로 데이터베이스를 사용할 수 있다.

![img.png](/assets/img/posts/database/study-1-1/img.png)

## Internal Schema
데이터가 물리적으로 저장된 표현 방식을 나타내는 계층이다.
Internal View는 전체 데이터베이스의 저장 구조를 표현한 것으로 저장 레코드의 타입, 저장 필드의 표현, 레코드의 물리적 순서, 색인 등을 나타낸다.

## Conceptual Schema
Conceptual View는 여러 External Views를 통합한 전체 DB의 논리적 구조를 표현한다.
데이터와 데이터의 관계, 무결성 제약 조건에 대한 명세를 정의한다.

## External Schema
사용자가 실제로 확인하는 부분으로 각 사용자의 관점에서의 데이터베이스 논리적 구조이다.
하나의 데이터에 서로 다른 관점을 가지므로 여러 개의 External View가 존재할 수 있다.
사용자는 DB SQL을 호출하는 DSL(Data Sub Languange)를 사용하여 External View를 사용한다.

---
# 5. 데이터 독립성
각각의 응용 프로그램이 다른 저장 데이터 구조를 사용하여 사용하면 여러 문제가 발생할 수 있다.
응용 프로그램의 코드가 데이터 구성과 접근 방법을 기반으로 구현되는 데이터 종속 상태인 경우 데이터 구성이 변경되면 응용 프로그램을 수정해야 한다.
또한 다른 데이터 구성을 가진 응용 프로그램에게 View를 제공하는 것이 불가능하다.

데이터베이스는 DBMS가 레코드의 저장과 응용 프로그램의 데이터 타입 간 변환 처리를 담당하므로 어떤 응용 프로그램이나 물리적인 저장 장치의 제약 없이 데이터에 접근할 수 있다.

## 물리적 데이터 독립성
Conceptual Schema를 Internal Schema와 분리한다.
따라서 특정 파일 시스템에 종속되는 문제를 해결하여 Internal Schema가 변경되더라도 Conceptual Schema는 영향을 받지 않는다.

## 논리적 데이터 독립성
External Schema를 Conceptual Schema와 분리한다.
따라서 테이블 구조가 바뀌거나 테이블 사이의 관계가 변경되어도 사용자나 응용 프로그램이 보는 External Schema는 영향을 받지 않는다.

---
# 6. RDBMS란?
관계형 데이터베이스는 테이블, 행, 열로(릴레이션으로) 구조화하는 방식이다. 이러한 테이블 간의 관계를 정의하여 데이터를 구성하고 관리한다.
관계형 데이터베이스 관리 시스템은 이러한 관계형 데이터베이스를 관리하는 소프트웨어이다.
이 관계형 데이터베이스에서 핵심은 **선언적 쿼리**이다.

## 선언적 쿼리
선언적 쿼리는 결과를 얻기 위한 연산을 표현하지 않고 시스템에서 추출할 내용을 정의한다.
예를 들어,
```sql
SELECT * FROM EMPLOYEE WHERE age >= 40
```
이 SQL 문은 40살 이상인 근로자를 출력하라는 결과만을 요청하고 이 결과를 얻기 위해 어떤 연산을 해야 하는지 지정하지 않는다.
연산을 표현하지 않고 원하는 내용을 정의하여 결과를 얻는 방식이다.

## 관계형 데이터베이스의 이점
관계형 데이터베이스 모델은 직관적인 데이터 표현 방법을 제공하고 쉽게 데이터에 접근할 수 있도록 한다.
데이터 정규화로 데이터 중복성을 줄이고 SQL을 사용하여 편리하게 복잡한 질의를 할 수 있는 등 다양한 이점을 가진다.

---
# 7. 릴레이션 스키마 & 릴레이션 인스턴스
사전적으로 '관계'를 뜻하는 릴레이션은 관계형 데이터베이스에서 가장 중요한 개념이다.
관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위로 하나의 테이블은 하나의 릴레이션으로 볼 수 있다.
이러한 릴레이션은 **릴레이션 스키마**와 **릴레이션 인스턴스**로 구성된다.

![img.png](/assets/img/posts/database/study-1-1/img-2.png)

## 릴레이션 스키마
릴레이션 스키마는 각 열들의 이름과 속성을 가진다.
테이블에서 (사번, 이름, 경력, 부서)처럼 속성의 이름들을 묶어 릴레이션 스키마로 볼 수 있다.

## 릴레이션 인스턴스
실제로 저장되어 있는 데이터이다. 
하나의 행에 저장되어 있는 데이터를 튜플이라 하고 이러한 튜플들이 모여 릴레이션 인스턴스가 되는 것이다.

---
# 8. 릴레이션 차수 & 카디널리티
## 릴레이션 차수
릴레이션에서 차수는 속성의 수를 말한다.
차수는 항상 1개 이상이 되어야 한다.
간단하게 말하면 테이블에서 열의 개수이다.

## 릴레이션 카디널리티
릴레이션에서 카디널리티는 튜플의 수를 말한다.
간단하게 말하면 테이블에서 행의 수이다.
이 때 튜플들의 값은 서로 중복되지 않아야 한다.

---
# 9. 키
무결성 조건에는 column의 범위 값을 정하는 business rules과 테이블 간의 참조 관계에 따라 기술하는 integrity rules가 있다.
이 때 이러한 참조 관계에서 기본키와 외래키를 활용한다.

| student_id | name | RRN           | department |
|------------|------|---------------|------------|
| 1          | 홍길동  | 990202-111111 | 컴퓨터공학      |
| 2          | 홍길동  | 000601-333333 | 기계공학       |
| 3          | 김민수  | 020202-333333 | 컴퓨터공학      |

## 기본키(Primary key)
릴레이션에서 식별자로 선택되는 속성이다. 
후보키 중에서 기본키를 하나 정하게 되면 나머지 키는 대체키가 된다.

## 후보키(Candidate Key)
후보키는 **유일성과 최소성을 갖는 속성들의 집합**이다.
1. 릴레이션 내에서 어떠한 속성 내 모든 튜플의 값이 중복되지 않으면 유일성을 가진다고 한다.
2. 후보키의 어떠한 부분집합도 유일성을 만족하지 않을 때 최소성을 가진다고 한다.

위의 예시에서 student_id는 튜플의 값이 중복되지 않으므로 student_id 만으로 데이터를 구분할 수 있다.
또한 RRN도 중복되지 않는 고유한 값으로 RRN 만으로 데이터를 구분할 수 있다.
따라서 이 테이블에서 후보키는 student_id, RRN이다.

## 슈퍼키(Super Key)
슈퍼키는 후보키를 포함하여 다른 속성들이 추가된 것이다.
이 키는 **유일성을 가지지만 최소성을 가질 수 없다.**

위의 예시에서 student_id와 name을 예시로 들어보자.
student_id와 name이 모두 일치하는 튜플은 없으므로 유일성을 만족한다.
하지만 이 슈퍼키의 부분 집합인 student_id도 유일성을 만족하므로 최소성을 가지지 않는다.
name이란 속성 없이 student_id 만으로 충분히 데이터를 구분할 수 있다는 뜻이다.

## 대체키(Alternate Key)
후보키 중에 하나를 기본키로 지정하고 남은 후보키들을 대체키라고 한다.

위의 예시에서 student_id를 기본키로 지정하면 age는 대체키가 된다.
student_id가 없는 상황에서 RRN는 다른 사람을 구별하는 키로 사용할 수 있다.


## 외래키(Foreign Key)
책의 정의는 다음과 같다.

> Foreign Key를 릴레이션2(R2)의 attribute 집합이라 하고 릴레이션1(R1)의 CK(후보키)가 있다. R2의 FK에 대하여 대응되는 R1 CK값이 존재한다.

정리하면 외래키는 관계형 데이터베이스에서 두 테이블을 서로 연결하는데 사용되는 키로 외래키는 다른 테이블의 후보키와 매핑된다.

## 대리키(Surrogate Key)
인위적으로 추가하는 식별자이다.
많은 데이터베이스에서 증가하는 정수로 데이터를 구분할 수 있도록 하는 대리키를 지원한다.

---
# 10. 무결성 제약 조건
데이터 무결성은 테이블에 신뢰할 수 없는 데이터 입력을 하지 못하도록 하는 제약 조건이다.
이 무결성 제약 조건으로 데이터의 무결성(일관성, 신뢰)을 보장할 수 있다.

## 도메인 무결성
속성의 값들은 일관성을 가져야 하며 업무 규칙에 부합되어야 한다.
이를 위해 특정 속성별로 범위 값을 제한할 수 있다.

예를 들어 사람의 나이는 음수가 될 수 없고 200살 이상이 될 수 없다.
이 경우 SQL의 `CHECK`를 활용하여 정상 범위 밖인 데이터가 입력되었을 때 오류를 발생시키도록 한다.

## 개체 무결성
기본키는 각 튜플을 데이터베이스 내에서 고유하게 식별될 수 있도록 보장하는 규칙이다.

기본키의 경우 중복과 Null 값을 허용하지 않는다.
따라서 기본키는 유일성과 더불어 Null 값 또한 허용하지 않는다.

## 참조 무결성
타 테이블과 연관된 데이터가 입력, 수정, 삭제 시에도 데이터 간에 정확한 참조 관계를 유지시킨다.

외래키에 적용되는 개념으로 외래키가 어떠한 데이터를 참조할 때 이 데이터는 반드시 존재하는 값이어야 한다.
외래키가 유효하지 않은 데이터를 참조한다면 데이터의 일관성에 문제가 생길 수 있다.
이러한 참조 무결성을 만족하기 위해 `CASCADE`를 활용하여 참조하는 행을 삭제할 때 해당 행을 참조하는 모든 행을 함께 삭제하여 무결성을 만족하도록 구현할 수 있다.
또는 외래키 값을 NULL로 변경하여 참조 무결성을 유지할 수 있다.

---
# 11. MySQL 엔진
스토리지 엔진은 각기 다른 테이블의 SQL 작업을 처리하는 MySQL 구성요소 중 하나이다.
MySQL은 InnoDB를 기본으로 하여 MyISAM, NDB, Archive 등 여러 스토리지 엔진을 지원한다.

## InnoDB
MyISAM과 달리 transaction 기능(ACID)을 지원하고 row-level locking, MVCC, foreign key 등을 지원한다.
InnoDB에서는 tablespace 개념을 지원하여 다양한 tablespace를 통해 테이블을 최적화할 수 있다.
InnoDB는 여러 고급 기능을 지원하여 데이터의 무결성을 보장함과 동시에 고성능을 보장한다.

- MVCC: 다양한 Transaction Isolation Level을 지원하여 동시성 제어를 할 수 있다.

# Reference
홍봉희 편저, 데이터베이스 SQL 프로그래밍 'MySQL 실습', 부산대학교출판문화원

[https://www.geeksforgeeks.org/difference-between-file-system-and-dbms/](https://www.geeksforgeeks.org/difference-between-file-system-and-dbms/)

[https://velog.io/@sdk1926/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90](https://velog.io/@sdk1926/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90)

[https://www.ibm.com/kr-ko/topics/database-schema](https://www.ibm.com/kr-ko/topics/database-schema)

[https://www.geeksforgeeks.org/introduction-of-3-tier-architecture-in-dbms-set-2/](https://www.geeksforgeeks.org/introduction-of-3-tier-architecture-in-dbms-set-2/)

[https://cloud.google.com/learn/what-is-a-relational-database?hl=ko](https://cloud.google.com/learn/what-is-a-relational-database?hl=ko)

[https://devparker.tistory.com/101](https://devparker.tistory.com/101)

[https://blog.naver.com/jenny1257/222526340713](https://blog.naver.com/jenny1257/222526340713)

[http://contents.kocw.or.kr/document/lec/2011_2/dunksung/ParkUchang/02.pdf](http://contents.kocw.or.kr/document/lec/2011_2/dunksung/ParkUchang/02.pdf)

[http://www.ktword.co.kr/test/view/view.php?no=610](http://www.ktword.co.kr/test/view/view.php?no=610)
